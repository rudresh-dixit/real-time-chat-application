
//We have no import statements likein react as it is node environment.
const express = require('express');
const socketio = require('socket.io');
const http = require('http');
const cors = require('cors');

// Access to the various utility functions.
const { addUser, removeUser, getUser, getUsersInGroup } = require('./users');

const PORT = process.env.PORT || 5000;

// since we have exported the router, we now can require it.
const router = require('./router');

const app = express();
const server = http.createServer(app);

// Just a rundown to make this socket.io server working.
const io = socketio(server);
 




// Now we need to setup socket.io.
// It is used for majority of data transfer in this application.
// Real time analytics also can be done efficiently.
// With socket.io we can do anything that is real time.
// To achieve this, we need to use sockets, not http requests.
// http requests are slow.
// We need to use websockets which socket.io is using
// to actually show something in real time.




// This io.on is going to run whenever we have a connection
// to a client on our io instance.

// io.on requires two parameters, a keyword which here in this case
// is 'connection' whenever we have a client connection.
// The other parameter is a callback function which is going to 
// be called.
// The callback function requires socket. This is going to be a socket 
// that is going to be connected as a client side socket. 

// All the calls must be in this function only as it is managing the
// socket in which we are interested.
io.on('connection', (socket) => {

    // It captures the emitted event on client side with named
    // string join.
    // The second parameter it receives is a callback function.

    // Now we get access on the backend with name and group.
    // Another thing is we can pass in a callback to the function as
    // second parameter.
    socket.on('join', ({ name, group }, callback) => {

        // Destructure the error and user objects.
        // addUser() function can return only two things - 
        // An object that have an error property or that has
        // a user property.
        const { error, user } = addUser({ id: socket.id, name, group });

        // Error message is dynamically coming based on the
        // specific error.
        if(error) return callback(error);

        // we simply need to emit a new event.
        socket.emit('message', { user: 'Bot', text: `${ user.name }, welcome to the group ${ user.group }.` });
        socket.emit('message', { user: 'Bot', text:  `Hey, I am a bot and this message was generated by me automatically.`})

        // It sends a message to everyone besides that specific user.
        socket.broadcast.to(user.group).emit('message', { user: 'Bot', text: `${ user.name } has joined.` });
        
        // Another built in method. Joins a user in a group.
        socket.join(user.group);

        // Logic to see what users are in the group.
        io.to(user.group).emit('roomData', { group: user.group, users: getUsersInGroup(user.group)});

        // We can actually trigger some response immediately after
        // the socket.on event is being emitted.
        // We can actually do some error handling with this callback.
        callback(/* parameters to be passed to client side. */);
    });
    

    
    // Creates an event for user generated messages. 
    // We want to expect the event on backend.
    // Emitting part is actually going to happen at the frontend.
    // We get transported to the frontend to emit those events.
    socket.on('sendMessage', (message, callback) => {

        // Getting the user having the specific socket id.
        const user = getUser(socket.id);

        // io.to(user.group).emit('message', { user: user.name, text: message });
        // io.to(user.group).emit('roomData', { group: user.group, users: getUsersInGroup(user.group) });
        
        // We are actually going to call the callback to do
        // something in the frontend after the message is sent.
        callback();
    })
   
    // Clients leaving from our socket.io application.
    socket.on('disconnect', () => {
        console.log("User Had left!!");

        // Remove the user after it left.
        const user = removeUser(socket.id); 

        // Inform the removal of users to other participants.
        if(user) {
            io.to(group).emit('message', { user: 'Bot', text: `${ user.name } has left.` }); 
        }
    })
})

app.use((req, res, next) => {
    res.header('Access-Control-Allow-Origin', '*');
    res.header('Access-Control-Allow-Headers', '*');
    if(req.method === 'OPTIONS') {
        res.header('Access-Control-Allow-Methods', '*');
        return res.status(200).json({});
    }
})

// We actually can use the router we had created.
app.use(router);
app.use(cors());

app.use(function(req, res, next) {
  res.header("Access-Control-Allow-Origin", "localhost:3000"); // update to match the domain you will make the request from
  res.header("Access-Control-Allow-Headers", "Origin, X-Requested-With, Content-Type, Accept");
  next();
});


// server.listen needs two parameters. 
// One the port and the other is a callback function. 
server.listen(PORT, () => console.log(`Server Running at port ${ PORT }...`));

